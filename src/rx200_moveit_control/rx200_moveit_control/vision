#!/usr/bin/env python3
"""
Cube Detection Vision Node for RX200 Robot
Detects 3 colored cubes (Red, Blue, Yellow) and returns their positions
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2
import numpy as np

class CubeDetectionNode(Node):
    """
    Detects colored cubes (square shapes) in real-time camera feed
    Returns position of each cube for pick-and-place
    """
    
    def __init__(self):
        super().__init__('cube_detection_node')
        
        # Initialize CV Bridge
        self.bridge = CvBridge()
        
        # Subscribe to camera color images
        self.image_sub = self.create_subscription(
            Image,
            '/camera/camera/color/image_raw',
            self.image_callback,
            10
        )
        
        # Detection storage
        self.detected_cubes = []
        self.frame_count = 0
        self.display_image = None
        
        # Color ranges for RGB cubes (HSV format)
        # Tuned for typical lighting conditions
        self.color_ranges = {
            'Red': (np.array([170, 50, 50]), np.array([195, 255, 255])),
            'Blue': (np.array([100, 150, 50]), np.array([130, 255, 255])),
            'Yellow': (np.array([15, 100, 100]), np.array([35, 255, 255])),
        }
        

        self.get_logger().info('‚úì Cube Detection Node Initialized')
        self.get_logger().info('Looking for 3 cubes: Red, Blue, Yellow')
        self.get_logger().info('Waiting for camera images...')

    def image_callback(self, msg):
        """Process each camera frame"""
        try:
            # Convert ROS Image to OpenCV
            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            self.display_image = cv_image.copy()
            
            # Detect cubes in this frame
            self.detect_cubes(cv_image)
            
            # Log results every 30 frames (~1 second at 30 FPS)
            self.frame_count += 1
            if self.frame_count % 30 == 0:
                self.log_cube_positions()
            
            # Display (optional)
            self.display_results(cv_image)
            
        except Exception as e:
            self.get_logger().error(f'Error processing image: {str(e)}')

    def detect_cubes(self, image):
        """
        Main cube detection pipeline
        1. Convert to HSV
        2. Detect each color
        3. Find contours
        4. Filter for squares (cubes seen from front)
        5. Store results
        """
        
        # Convert to HSV for better color detection
        hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        
        # Reset detection list
        self.detected_cubes = []
        
        # Detect each cube color
        for color_name, (lower, upper) in self.color_ranges.items():
            
            # Create mask for this color
            mask = cv2.inRange(hsv_image, lower, upper)
            
            # Clean up noise
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
            mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
            mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
            
            # Find contours
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, 
                                          cv2.CHAIN_APPROX_SIMPLE)
            
            # Process each potential cube
            for contour in contours:
                cube_info = self.is_cube(contour, color_name)
                if cube_info:
                    self.detected_cubes.append(cube_info)
                    self.draw_cube(self.display_image, cube_info, contour)

    def is_cube(self, contour, color):
        """
        Determine if a contour is a cube
        Cubes appear as squares/rectangles from camera view
        """
        
        # Filter by area (adjust based on distance)
        area = cv2.contourArea(contour)
        if area < 1000 or area > 50000:  # Cube size range
            return None
        
        # Approximate to polygon
        epsilon = 0.04 * cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, epsilon, True)
        
        # Must have 4 vertices (square/rectangle)
        if len(approx) != 4:
            return None
        
        # Get bounding rectangle
        x, y, w, h = cv2.boundingRect(contour)
        
        # Check aspect ratio (cubes should be roughly square)
        aspect_ratio = float(w) / h if h > 0 else 0
        if not (0.7 < aspect_ratio < 1.4):  # Allow some perspective distortion
            return None
        
        # Calculate center point
        M = cv2.moments(contour)
        if M['m00'] > 0:
            cx = int(M['m10'] / M['m00'])
            cy = int(M['m01'] / M['m00'])
        else:
            return None
        
        # This is a valid cube!
        return {
            'color': color,
            'center_x': cx,
            'center_y': cy,
            'area': area,
            'width': w,
            'height': h,
            'aspect_ratio': aspect_ratio,
            'bounding_box': (x, y, w, h)
        }

    def draw_cube(self, image, cube_info, contour):
        """Draw detected cube on image"""
        
        # Color mapping for display (BGR format)
        draw_colors = {
            'Red': (0, 0, 255),
            'Blue': (255, 0, 0),
            'Yellow': (0, 255, 255),
        }
        
        color = draw_colors.get(cube_info['color'], (255, 255, 255))
        
        # Draw contour
        cv2.drawContours(image, [contour], 0, color, 3)
        
        # Draw center point
        cv2.circle(image, 
                  (cube_info['center_x'], cube_info['center_y']),
                  7, color, -1)
        
        # Draw bounding box
        x, y, w, h = cube_info['bounding_box']
        cv2.rectangle(image, (x, y), (x+w, y+h), color, 2)
        
        # Add label
        label = f"{cube_info['color']} CUBE"
        cv2.putText(image, label,
                   (cube_info['center_x'] - 50, cube_info['center_y'] - 20),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

    def log_cube_positions(self):
        """
        Log detected cube positions to terminal
        This is what you'll use for pick-and-place!
        """
        
        if not self.detected_cubes:
            self.get_logger().info('‚ùå No cubes detected')
            return
        
        self.get_logger().info('‚ïê' * 70)
        self.get_logger().info(f'üì¶ DETECTED {len(self.detected_cubes)} CUBE(S):')
        self.get_logger().info('‚ïê' * 70)
        
        # Sort by color for consistent output
        sorted_cubes = sorted(self.detected_cubes, key=lambda x: x['color'])
        
        for i, cube in enumerate(sorted_cubes, 1):
            self.get_logger().info(
                f"[{i}] {cube['color']:6} CUBE ‚Üí "
                f"Position: ({cube['center_x']:4}, {cube['center_y']:4}) | "
                f"Size: {cube['width']}x{cube['height']} px | "
                f"Area: {cube['area']:.0f}"
            )
        
        self.get_logger().info('‚ïê' * 70)
        
        # If all 3 cubes found, print summary
        if len(self.detected_cubes) == 3:
            self.get_logger().info('‚úÖ ALL 3 CUBES DETECTED!')
            #self.print_pick_order()
        else:
            self.get_logger().warn(f'‚ö† Only {len(self.detected_cubes)}/3 cubes detected')


    def display_results(self, image):
        """Display image with detections (optional, for debugging)"""
        
        try:
            # Add header
            cv2.putText(image, 'Cube Detection - Press Q to exit',
                       (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            
            # Add count
            cv2.putText(image, f'Cubes: {len(self.detected_cubes)}/3',
                       (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            
            # Show image
            cv2.imshow('Cube Detection', image)
            
            # Check for quit
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                self.get_logger().info('Shutting down...')
                raise KeyboardInterrupt
                
        except Exception as e:
            pass  # Silent fail if no display available

    def get_cube_positions(self):
        """
        Return current detected cube positions
        Call this from pick-and-place node
        """
        return self.detected_cubes


def main(args=None):
    rclpy.init(args=args)
    
    node = CubeDetectionNode()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Cube Detection Node shutting down...')
    finally:
        node.destroy_node()
        rclpy.shutdown()
        cv2.destroyAllWindows()


if __name__ == '__main__':
    main()
